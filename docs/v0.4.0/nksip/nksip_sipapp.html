<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Module nksip_sipapp</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module nksip_sipapp</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>SipApp callback behaviour and callbacks default implementation.

<p><b>This module defines the <tt>nksip_sipapp</tt> behaviour.</b><br> Required callback functions: <tt>init/1</tt>.</p>

<h2><a name="description">Description</a></h2><p>SipApp callback behaviour and callbacks default implementation.</p>
 
  <p>All of the available functions you can implement in your callback module are described  
here, along with the default implementation of each one.</p>
 
  <p>Every <b>SipApp</b> must define a <i>callback module</i>, using this module's behaviour.
  This behaviour works in a very similar way to any standard Erlang <code>gen_server</code>'s
  callback module, but only <a href="#init-1"><code>init/1</code></a> is mandatory.</p>
 
  <p>Depending on the phase of the request processing, different functions will be called.
  Some of these calls expect an answer from the SipApp to continue the processing,
  and some others are called to inform the SipApp about a specific event and don't
  expect any answer. As in <code>gen_server</code>, the current SipApp state (created in the call
  to <code>init/1</code>) will be sent in every call, and can be updated by the SipApp  
implementation in every function return.</p>
 
  <p>Except for <code>init/1</code>, all defined functions belong
  to one of two groups: <i>expected answer</i> functions and
  <i>no expected answer</i> functions.</p>
 
  The supported return values for <i>expected answer functions</i> are:
  <pre>    call_reply() ::
        {noreply, State} | {noreply, State, Timeout} |
        {reply, Reply, State} | {reply, Reply, State, Timeout} |
        {stop, Reason, State} | {stop, Reason, Reply, State}
        when State :: term(), Timeout :: infinity | non_neg_integer(), Reason :: term()</pre>
 
  <p>The function is expected to return <code>State</code> as new SipApp user's state and a <code>Reply</code>,
  whose meaning is specific to each function and it is described bellow.
  If a <code>Timeout</code> is defined the SipApp process will receive a <code>timeout</code> message
  after the indicated milliseconds period (you must implement <a href="#handle_info-2"><code>handle_info/2</code></a>
  to receive it).
  If the function returns <code>stop</code> the SipApp will be stopped.
  If the function does not want to return a reply just know, it must return
  <code>{noreply, State}</code> and call <a href="nksip.html#reply-2"><code>nksip:reply/2</code></a> later on,  
possibly from a different spawned process.</p>
 
  The supported return values for <i>no expected answer functions</i> are:
  <pre>    call_noreply() ::
        {noreply, State} | {noreply, State, Timeout} |
        {stop, Reason, State}
        when State :: term(), Timeout :: infinity | non_neg_integer(), Reason :: term()</pre>
 
  <p>Some of the callback functions allow the SipApp to send a response back
  to the calling party. See the available responses in <a href="nksip_reply.html"><code>nksip_reply</code></a>.</p>
 
  The usual call order is the following:
  <ol>
   <li>When starting the SipApp, <a href="#init-1"><code>init/1</code></a> is called to initialize the
       application state.</li>
   <li>When a request is received having an <i>Authorization</i> or
       <i>Proxy-Authorization</i> header, <a href="#get_user_pass-3"><code>get_user_pass/3</code></a> is called to check
       the user's password.</li>
   <li>NkSIP calls <a href="#authorize-4"><code>authorize/4</code></a> to check is the request should be
       authorized.</li>
   <li>If authorized, it calls <a href="#route-6"><code>route/6</code></a> to decide what to do with the
       request: reply, route or process locally.</li>
   <li>If the request is going to be processed locally, <a href="#invite-3"><code>invite/3</code></a>,
       <a href="#options-3"><code>options/3</code></a>, <a href="#register-3"><code>register/3</code></a> or <a href="#bye-3"><code>bye/3</code></a> are called,
       and the user must send a reply.
       If the request is a valid <i>CANCEL</i>, belonging to an active <i>INVITE</i>
       transaction, the INVITE is cancelled and <a href="#cancel-2"><code>cancel/2</code></a> is called.</li>
   <li>After sending a successful response to an <i>INVITE</i> request,
       the other party will send an <i>ACK</i> and <a href="#ack-3"><code>ack/3</code></a> will be called.</li>
   <li>If the request creates or modifies a dialog and/or a SDP session,
       <a href="#dialog_update-3"><code>dialog_update/3</code></a> and/or <a href="#session_update-3"><code>session_update/3</code></a> are called.</li>
   <li>If the remote party sends an in-dialog invite (a <i>reINVITE</i>),
       NkSIP will call <a href="#reinvite-3"><code>reinvite/3</code></a>.</li>
   <li>If the user has set up an automatic ping or registration,
       <a href="#ping_update-3"><code>ping_update/3</code></a> or <a href="#register_update-3"><code>register_update/3</code></a> are called on each
       status change.</li>
   <li>When the SipApp is stopped, <a href="#terminate-2"><code>terminate/2</code></a> is called.</li>
  </ol>
 
 
  <p>It is <b>very important</b> to notice that, as in using normal <code>gen_server</code>,  
there is a single SipApp core process, so you must not spend a long time in any of  
the callback functions. If you do so, new requests arriving at your SipApp will be  
blocked and the other party will start to send retransmissions. As no transaction  
has been created yet, NkSIP will see them as new requests that will be also blocked,  
and so on.</p>
 
  <p>If the expected processing time of any of your callback functions is high
  (more than a few milliseconds), you must spawn a new process, return <code>{noreply, ...}</code>
  and do any time-consuming work there. If the called function spawning the process is
  in the expected answer group, it must call <a href="nksip.html#reply-2"><code>nksip:reply/2</code></a> from the spawned  
process when a reply is available.  
Launching new processes in Erlang is a very cheap operation,  
so in case of doubt follow this recommendation.</p>
 
  <p>Many of the callback functions receive a <code>RequesId</code> (<a href="nksip_request.html#type-id"><code>nksip_request:id()</code></a>)
  object as first parameter, representing a pointer to the actual request. You can
  use the helper funcions in <a href="nksip_request.html"><code>nksip_request</code></a> to extract any information from it,
  and, it it is liked to a dialog, the functions in <a href="nksip_dialog.html"><code>nksip_dialog</code></a>.</p>
 
  <p><b>Inline functions</b></p>
 
  <p>NkSIP offers another option for defining callback functions. Most of them have
  an <i>inline</i> form. If defined, it will be called instead of the <i>normal</i> form.</p>
 
  <p>Inline functions have the same name of normal functions, but they don't have the
  <code>State</code> parameter. They are called in-process, inside the call processing process and  
not from the SipApp's process like the normal functions.</p>
 
  Inline functions are much quicker, but they can't modify the SipApp state.
  They received a full <a href="nksip.html#type-request"><code>nksip:request()</code></a> object instead of a request's id,
  so they must use the functions in <a href="nksip_sipmsg.html"><code>nksip_sipmsg</code></a> instead of
  <a href="nksip_request.html"><code>nksip_request</code></a>.
  See <code>inline_test</code> for an example of use
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-call_noreply">call_noreply()</a></h3>
<p><tt>call_noreply() = {noreply, State::term()} | {noreply, State::term(), Timeout::timeout()} | {stop, Reason::term(), State::term()}</tt></p>


<h3 class="typedecl"><a name="type-call_reply">call_reply()</a></h3>
<p><tt>call_reply(RetType) = {reply, Reply::RetType, State::term()} | {reply, Reply::RetType, State::term(), Timeout::timeout()} | {noreply, State::term()} | {noreply, State::term(), Timeout::timeout()} | {stop, Reason::term(), Reply::RetType, State::term()} | {stop, Reason::term(), State::term()}</tt></p>


<h3 class="typedecl"><a name="type-init_return">init_return()</a></h3>
<p><tt>init_return() = {ok, State::term()} | {ok, State::term(), Timeout::timeout()} | {stop, Reason::term()}</tt></p>


<h3 class="typedecl"><a name="type-registrar_store_op">registrar_store_op()</a></h3>
<p><tt>registrar_store_op() = {get, <a href="nksip.html#type-aor">nksip:aor()</a>} | {put, <a href="nksip.html#type-aor">nksip:aor()</a>, [<a href="nksip_registrar.html#type-reg_contact">nksip_registrar:reg_contact()</a>], integer()} | {del, <a href="nksip.html#type-aor">nksip:aor()</a>} | del_all</tt></p>


<h3 class="typedecl"><a name="type-route_reply">route_reply()</a></h3>
<p><tt>route_reply() = proxy | {proxy, ruri | <a href="nksip.html#type-uri_set">nksip:uri_set()</a>} | {proxy, ruri | <a href="nksip.html#type-uri_set">nksip:uri_set()</a>, <a href="nksip_lib.html#type-proplist">nksip_lib:proplist()</a>} | process | {process, <a href="nksip_lib.html#type-proplist">nksip_lib:proplist()</a>} | {response, <a href="nksip.html#type-sipreply">nksip:sipreply()</a>} | {response, <a href="nksip.html#type-sipreply">nksip:sipreply()</a>, <a href="nksip_lib.html#type-proplist">nksip_lib:proplist()</a>}</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#ack-3">ack/3</a></td><td>Called when a valid ACK request is received.</td></tr>
<tr><td valign="top"><a href="#authorize-4">authorize/4</a></td><td>Called for every incoming request to be authorized or not.</td></tr>
<tr><td valign="top"><a href="#bye-3">bye/3</a></td><td>Called when a valid BYE request is received.</td></tr>
<tr><td valign="top"><a href="#cancel-2">cancel/2</a></td><td>Called when a pending INVITE request is cancelled.</td></tr>
<tr><td valign="top"><a href="#dialog_update-3">dialog_update/3</a></td><td>Called when a dialog has changed its state.</td></tr>
<tr><td valign="top"><a href="#get_user_pass-3">get_user_pass/3</a></td><td>Called to check a user password for a realm.</td></tr>
<tr><td valign="top"><a href="#handle_call-3">handle_call/3</a></td><td>Called when a direct call to the SipApp process is made using
  <a href="nksip.html#call-2"><code>nksip:call/2</code></a> or <a href="nksip.html#call-3"><code>nksip:call/3</code></a>.</td></tr>
<tr><td valign="top"><a href="#handle_cast-2">handle_cast/2</a></td><td>Called when a direct cast to the SipApp process is made using
  <a href="nksip.html#cast-2"><code>nksip:cast/2</code></a>.</td></tr>
<tr><td valign="top"><a href="#handle_info-2">handle_info/2</a></td><td>Called when the SipApp process receives an unknown message.</td></tr>
<tr><td valign="top"><a href="#info-3">info/3</a></td><td>Called when a valid INFO request is received.</td></tr>
<tr><td valign="top"><a href="#init-1">init/1</a></td><td>SipApp initialization.</td></tr>
<tr><td valign="top"><a href="#invite-3">invite/3</a></td><td>This function is called by NkSIP to process a new INVITE request as an endpoint.</td></tr>
<tr><td valign="top"><a href="#message-3">message/3</a></td><td>This function is called by NkSIP to process a new incoming MESSAGE  
request.</td></tr>
<tr><td valign="top"><a href="#notify-3">notify/3</a></td><td>This function is called by NkSIP to process a new incoming NOTIFY  
request belonging to a current active subscription.</td></tr>
<tr><td valign="top"><a href="#options-3">options/3</a></td><td>Called when a OPTIONS request is received.</td></tr>
<tr><td valign="top"><a href="#ping_update-3">ping_update/3</a></td><td>Called when the status of an automatic ping configuration changes.</td></tr>
<tr><td valign="top"><a href="#prack-3">prack/3</a></td><td>Called when a valid PRACK request is received.</td></tr>
<tr><td valign="top"><a href="#register-3">register/3</a></td><td>This function is called by NkSIP to process a new incoming REGISTER request.</td></tr>
<tr><td valign="top"><a href="#register_update-3">register_update/3</a></td><td>Called when the status of an automatic registration configuration changes.</td></tr>
<tr><td valign="top"><a href="#registrar_store-3">registrar_store/3</a></td><td>Called when a operation database must be done on the registrar database.</td></tr>
<tr><td valign="top"><a href="#reinvite-3">reinvite/3</a></td><td>This function is called when a new in-dialog INVITE request is received.</td></tr>
<tr><td valign="top"><a href="#route-6">route/6</a></td><td>This function is called by NkSIP for every new request, to check if it must be
  proxied, processed locally or replied immediately.</td></tr>
<tr><td valign="top"><a href="#session_update-3">session_update/3</a></td><td>Called when a dialog has updated its SDP session parameters.</td></tr>
<tr><td valign="top"><a href="#subscribe-3">subscribe/3</a></td><td>This function is called by NkSIP to process a new incoming SUBSCRIBE  
request that has an allowed Event type.</td></tr>
<tr><td valign="top"><a href="#terminate-2">terminate/2</a></td><td>Called when the SipApp is stopped.</td></tr>
<tr><td valign="top"><a href="#update-3">update/3</a></td><td>Called when a valid UPDATE request is received.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="ack-3">ack/3</a></h3>
<div class="spec">
<p><tt>ack(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(ok)</tt><br></p>
</div><p><p>Called when a valid ACK request is received.</p>
 
  This function is called by NkSIP when a new valid in-dialog ACK request has to
  be processed locally.
  You don't usually need to implement this callback. One possible reason to do it is
  to receive the SDP body from the other party in case it was not present in the INVITE
  (you can also get it from the <a href="#session_update-3"><code>session_update/3</code></a> callback).
 </p>

<h3 class="function"><a name="authorize-4">authorize/4</a></h3>
<div class="spec">
<p><tt>authorize(AuthList, ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(ok | authenticate | proxy_authenticate | forbidden)</tt>
<ul class="definitions"><li><tt>AuthList = [dialog | register | {{digest, Realm::binary}, boolean()}]</tt></li></ul></p>
</div><p><p>Called for every incoming request to be authorized or not.</p>
 
  <p>If <code>ok</code> is replied the request is authorized and the
  request processing continues. If <code>authenticate</code> is replied, the request will be
  rejected (statelessly) with a 401 <i>Unauthorized</i>.
  The other party will usually send the request again, this time with an
  <code>Authorization</code> header. If you reply <code>proxy_authenticate</code>, it is rejected
  with a 407 <i>Proxy Authentication Rejected</i> response and the other party
  will include a <code>Proxy-Authorization</code> header.</p>
 
  You can use the tags included in <code>AuthList</code> in order to decide to authenticate
  or not the request.  AuthList includes the following tags:
  <ul>
     <li><code>dialog</code>: the request is in-dialog and coming from the same ip and port
         than the last request for an existing dialog.</li>
     <li><code>register</code>: the request comes from the same ip, port and transport of a
         currently valid registration (and the method is not <i>REGISTER</i>).</li>
     <li><code>{{digest, Realm}, true}</code>: there is at least one valid user authenticated
         (has a correct password) with this Realm.</li>
     <li><code>{{digest, Realm}, false}</code>: there is at least one user offering an
         authentication header for this Realm, but all of them
         have failed the authentication (no password was valid). </li>
  </ul>
 
  You will usually want to combine these strategies. Typically you will first
  check using SIP digest authentication, and, in case of faillure, you can use
  previous registration and/or dialog authentication.
  If you don't define this function all requests will be authenticated.
 </p>

<h3 class="function"><a name="bye-3">bye/3</a></h3>
<div class="spec">
<p><tt>bye(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(<a href="nksip.html#type-sipreply">nksip:sipreply()</a>)</tt><br></p>
</div><p><p>Called when a valid BYE request is received.</p>
 
  When a BYE request is received, NkSIP will automatically response 481
  <i>Call/Transaction does not exist</i> if it doesn't belong to a current dialog.
  If it does, NkSIP stops the dialog and this callback functions is called.
  You won't usually need to implement this function, but in case you do, you
  should reply <code>ok</code> to send a 200 response back.
 </p>

<h3 class="function"><a name="cancel-2">cancel/2</a></h3>
<div class="spec">
<p><tt>cancel(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, State::term()) -&gt; <a href="#type-call_noreply">call_noreply()</a></tt><br></p>
</div><p><p>Called when a pending INVITE request is cancelled.</p>
 
  <p>When a CANCEL request is received by NkSIP, it will check if it belongs to an
  existing INVITE transaction. If not, a 481 <i>Call/Transaction does not exist</i>  
will be automatically replied.</p>
 
  If it belongs to an existing INVITE transaction, NkSIP replies 200 <i>OK</i> to the
  CANCEL request. If the matching INVITE transaction has not yet replied a
  final response, NkSIP replies it with a 487 (Request Terminated) and this function
  is called. If a final response has already beeing replied, it has no effect.
 </p>

<h3 class="function"><a name="dialog_update-3">dialog_update/3</a></h3>
<div class="spec">
<p><tt>dialog_update(DialogId::<a href="nksip_dialog.html#type-id">nksip_dialog:id()</a>, DialogStatus, State::term()) -&gt; <a href="#type-call_noreply">call_noreply()</a></tt>
<ul class="definitions"><li><tt>DialogStatus = start | target_update | {invite_status, <a href="nksip_dialog.html#type-invite_status">nksip_dialog:invite_status()</a>} | {subscription_status, <a href="nksip_subscription.html#type-status">nksip_subscription:status()</a>} | {stop, <a href="nksip_dialog.html#type-stop_reason">nksip_dialog:stop_reason()</a>}</tt></li></ul></p>
</div><p><p>Called when a dialog has changed its state.</p>
 
  <p>A new dialog will be created when you send an INVITE request
  (using <a href="nksip_uac.html#invite-3"><code>nksip_uac:invite/3</code></a>) and a successful (101-299) response is received,
  or after an INVITE is received and the call to <code>invite/3</code> callback replies
  with a successful response. If the response is provisional (101-199) the dialog
  will be marked as temporary or <i>early</i>, waiting for the final response  
to be confirmed or deleted.</p>
 
  <p>Dialogs will also be created for <b>subscriptions</b>, after a valid NOTIFY is sent or
  received. Any dialog can have multiple usages simultaneously, as much as <i>one</i>  
'INVITE usage' and a unlimited number of 'SUBSCRIBE usages'.</p>
 
  <p>Once the dialog is established, some in-dialog methods
  (like INVITE, UPDATE, SUBSCRIBE and NOTIFY) can update the <code>target</code> of the dialog.</p>
 
  <p>The 'INVITE usage' is destroyed when a valid in-dialog BYE request is sent or received.  
A 'SUBSCRIPTION' usage is destroyed when a NOTIFY with status=terminated is  
received. When no usage is left, the dialog itself is destroyed.</p>
 
  <p>NkSIP will call this function every time a dialog is created, its target is updated  
or it is destroyed.</p>
 
  For INVITE usages, it will be called also when the status of the usage changes,
  as <code>{invite_status, <a href="nksip_dialog.html#type-invite_status"><code>nksip_dialog:invite_status()</code></a>}</code>.
  For SUBSCRIBE usages, also when the status of that usage changes, as
  {subscription_status, <a href="nksip_subscription.html#type-status"><code>nksip_subscription:status()</code></a>}.
 </p>

<h3 class="function"><a name="get_user_pass-3">get_user_pass/3</a></h3>
<div class="spec">
<p><tt>get_user_pass(User::binary(), Realm::binary(), State::term()) -&gt; {reply, Reply, NewState}</tt>
<ul class="definitions"><li><tt>Reply = true | false | binary()</tt></li><li><tt>NewState = term()</tt></li></ul></p>
</div><p><p>Called to check a user password for a realm.</p>
 
  <p>When a request is received containing a <code>Authorization</code> or <code>Proxy-Authorization</code>
  header, this function is called by NkSIP including the header's <code>User</code> and <code>Realm</code>,  
to check if the authorization data in the header corresponds to the user's password.</p>
 
  <p>You should normally reply with the user's password (if you have it for this user
  and realm). NkSIP will use the password and the digest information in the header
  to check if it is valid, offering this information in the call to
  <a href="#authorize-4"><code>authorize/4</code></a>.</p>
 
  <p>You can also reply <code>true</code> if you want to accept any request from this user
  without checking any password, or <code>false</code> if you don't have a password for this user  
or want her blocked.</p>
 
  <p>If you don't want to store <i>clear-text</i> passwords of your users,
  you can use <a href="nksip_auth.html#make_ha1-3"><code>nksip_auth:make_ha1/3</code></a> to generate a <i>hash</i> of the password  
for an user and a realm, and store only this hash instead of the real password.  
Later on you can reply here with the hash instead of the real password.</p>
 
  If you don't define this function, NkSIP will reply with password <code>&lt;&lt;&gt;&gt;</code>
  if user is <code>anonymous</code>, and <code>false</code> for any other user.
 </p>

<h3 class="function"><a name="handle_call-3">handle_call/3</a></h3>
<div class="spec">
<p><tt>handle_call(Msg::term(), From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(<a href="nksip.html#type-sipreply">nksip:sipreply()</a>)</tt><br></p>
</div><p>Called when a direct call to the SipApp process is made using
  <a href="nksip.html#call-2"><code>nksip:call/2</code></a> or <a href="nksip.html#call-3"><code>nksip:call/3</code></a>.</p>

<h3 class="function"><a name="handle_cast-2">handle_cast/2</a></h3>
<div class="spec">
<p><tt>handle_cast(Msg::term(), State::term()) -&gt; <a href="#type-call_noreply">call_noreply()</a></tt><br></p>
</div><p>Called when a direct cast to the SipApp process is made using
  <a href="nksip.html#cast-2"><code>nksip:cast/2</code></a>.</p>

<h3 class="function"><a name="handle_info-2">handle_info/2</a></h3>
<div class="spec">
<p><tt>handle_info(Msg::term(), State::term()) -&gt; <a href="#type-call_noreply">call_noreply()</a></tt><br></p>
</div><p>Called when the SipApp process receives an unknown message.</p>

<h3 class="function"><a name="info-3">info/3</a></h3>
<div class="spec">
<p><tt>info(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(<a href="nksip.html#type-sipreply">nksip:sipreply()</a>)</tt><br></p>
</div><p><p>Called when a valid INFO request is received.</p>
 
  When an INFO request is received, NkSIP will automatically response 481
  <i>Call/Transaction does not exist</i> if it doesn't belong to a current dialog.
  If it does, NkSIP this callback functions is called.
  If implementing this function, you should reply <code>ok</code> to send a 200 response back.
 </p>

<h3 class="function"><a name="init-1">init/1</a></h3>
<div class="spec">
<p><tt>init(Args::term()) -&gt; <a href="#type-init_return">init_return()</a></tt><br></p>
</div><p><p>SipApp initialization.</p>
 
  <p>This callback function is called when the SipApp is launched using
  <a href="nksip.html#start-4"><code>nksip:start/4</code></a>.</p>
 
  If <code>{ok, State}</code> or <code>{ok, State, Timeout}</code> is returned the SipApp is started with
  this initial state. If a <code>Timeout</code> is provided (in milliseconds) a
  <code>timeout</code> message will be sent to the process
  (you will need to implement <a href="#handle_info-2"><code>handle_info/2</code></a> to receive it).
  If <code>{stop, Reason}</code> is returned the SipApp will not start.
 </p>

<h3 class="function"><a name="invite-3">invite/3</a></h3>
<div class="spec">
<p><tt>invite(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(<a href="nksip.html#type-sipreply">nksip:sipreply()</a>)</tt><br></p>
</div><p><p>This function is called by NkSIP to process a new INVITE request as an endpoint.</p>
 
  <p>Before replying a final response, you will usually call
  <a href="nksip_request.html#reply-3"><code>nksip_request:reply/3</code></a> to send a provisional response like
  <code>ringing</code> (which would send a 180 <i>Ringing</i> reply).</p>
 
  <p>If a quick response (like <code>busy</code>) is not going to be sent immediately
  (which is typical for INVITE requests, as the user would normally need to accept
  the call) you must return <code>{noreply, NewState}</code> and spawn a new process,
  calling <a href="nksip.html#reply-2"><code>nksip:reply/2</code></a> from the new process, in order to avoid  
blocking the SipApp process.</p>
 
  <p>You can access the body of the request by calling <a href="nksip_request.html#body-2"><code>nksip_request:body/2</code></a>.
  INVITE requests will usually have a SDP body. If this is the case, and the
  <code>Content-Type</code> header contains <code>application/sdp</code>, NkSIP will decode the SDP and
  <code>nksip_request:body/2</code> will return a <a href="nksip_sdp.html#type-sdp"><code>nksip_sdp:sdp()</code></a> object you can manage
  with the functions in <a href="nksip_sdp.html"><code>nksip_sdp</code></a>.
  If it is not recognized it would return a binary, or <code>&lt;&lt;&gt;&gt;</code> if it is missing.</p>
 
  You must then answer the request. The possible responses are defined in
  <a href="nksip_reply.html"><code>nksip_reply</code></a>.
  If a successful (2xx) response is sent, you should include a new generated SDP body
  in the response. A new dialog will then start.
  The remote party should then send an ACK request immediately.
  If none is received, NkSIP will automatically stop the dialog.
 </p>

<h3 class="function"><a name="message-3">message/3</a></h3>
<div class="spec">
<p><tt>message(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(<a href="nksip.html#type-sipreply">nksip:sipreply()</a>)</tt><br></p>
</div><p><p>This function is called by NkSIP to process a new incoming MESSAGE  
request.</p>
 
  If you reply a 2xx response like <code>ok</code>  or <code>accepted</code>, you are telling
  to the remote party that the message has been received.
  Use a 6xx response (like <code>decline</code>) to tell it has been refused.
 </p>

<h3 class="function"><a name="notify-3">notify/3</a></h3>
<div class="spec">
<p><tt>notify(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(<a href="nksip.html#type-sipreply">nksip:sipreply()</a>)</tt><br></p>
</div><p><p>This function is called by NkSIP to process a new incoming NOTIFY  
request belonging to a current active subscription.</p>
 
  You should always return <code>ok</code>.
 </p>

<h3 class="function"><a name="options-3">options/3</a></h3>
<div class="spec">
<p><tt>options(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(<a href="nksip.html#type-sipreply">nksip:sipreply()</a>)</tt><br></p>
</div><p><p>Called when a OPTIONS request is received.</p>
 
  <p>This function is called by NkSIP to process a new incoming OPTIONS request as
  an endpoint. If not defined, NkSIP will reply with a 200 <i>OK</i> response,
  including automatically generated <code>Allow</code>, <code>Accept</code> and <code>Supported</code> headers.</p>
 
  NkSIP will not send any body in its automatic response. This is ok for proxies.
  If you are implementing an endpoint or B2BUA, you should implement this function
  and include in your response a SDP body representing your supported list of codecs,
  and also <code>Allow</code>, <code>Accept</code> and <code>Supported</code> headers.
 </p>

<h3 class="function"><a name="ping_update-3">ping_update/3</a></h3>
<div class="spec">
<p><tt>ping_update(PingId::term(), OK::boolean(), State::term()) -&gt; <a href="#type-call_noreply">call_noreply()</a></tt><br></p>
</div><p>Called when the status of an automatic ping configuration changes.
  See <a href="nksip_sipapp_auto.html#start_ping-5"><code>nksip_sipapp_auto:start_ping/5</code></a>.</p>

<h3 class="function"><a name="prack-3">prack/3</a></h3>
<div class="spec">
<p><tt>prack(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(ok)</tt><br></p>
</div><p><p>Called when a valid PRACK request is received.</p>
 
  This function is called by NkSIP when a new valid in-dialog PRACK request has to
  be processed locally, in response to a sent reliable provisional response.
  You don't usually need to implement this callback. One possible reason to do it is
  to receive the SDP body from the other party in case it was not present in the INVITE
  (you can also get it from the <a href="#session_update-3"><code>session_update/3</code></a> callback).
 </p>

<h3 class="function"><a name="register-3">register/3</a></h3>
<div class="spec">
<p><tt>register(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(<a href="nksip.html#type-sipreply">nksip:sipreply()</a>)</tt><br></p>
</div><p><p>This function is called by NkSIP to process a new incoming REGISTER request.</p>
 
  <p>If it is not defined, but <code>registrar</code> option was present in the SipApp's
  startup config, NkSIP will process the request.
  It will NOT check if <i>From</i> and <i>To</i> headers contains the same URI,
  or if the registered domain is valid or not. If you need to check this,
  implement this function returning <code>register</code> if everything is ok.
  See <a href="nksip_registrar.html"><code>nksip_registrar</code></a> for other possible response codes defined in the SIP  
standard registration process.</p>
 
  <p>If this function is not defined, and no <code>registrar</code> option is found,
  a 405 <i>Method not allowed</i> would be replied.</p>
 
  You should define this function in case you are implementing a registrar server
  and need a specific REGISTER processing
  (for example to add some headers to the response).
 </p>

<h3 class="function"><a name="register_update-3">register_update/3</a></h3>
<div class="spec">
<p><tt>register_update(RegId::term(), OK::boolean(), State::term()) -&gt; <a href="#type-call_noreply">call_noreply()</a></tt><br></p>
</div><p>Called when the status of an automatic registration configuration changes.
  See <a href="nksip_sipapp_auto.html#start_register-5"><code>nksip_sipapp_auto:start_register/5</code></a>.</p>

<h3 class="function"><a name="registrar_store-3">registrar_store/3</a></h3>
<div class="spec">
<p><tt>registrar_store(AppId::<a href="nksip.html#type-app_id">nksip:app_id()</a>, Op::<a href="#type-registrar_store_op">registrar_store_op()</a>, State::term()) -&gt; {reply, term(), term()}</tt><br></p>
</div><p><p>Called when a operation database must be done on the registrar database.</p>
 
  <p>The possible values for Op and their allowed reply are:</p>
 
 <table border="1">
    <tr><th>Op</th><th>Response</th><th>Comments</th></tr>
    <tr><td><code>{get, AOR::<a href="nksip.html#type-aor"><code>nksip:aor()</code></a>}</code></td>
       <td><code>[Contact::<a href="nksip_registrar.html#type-reg_contact"><code>nksip_registrar:reg_contact()</code></a>]</code></td>
       <td>Retrieve all stored contacts for this AOR.</td></tr>
    <tr><td><code>{put, AOR::<a href="nksip.html#type-aor"><code>nksip:aor()</code></a>, [Contact::<a href="nksip_registrar.html#type-reg_contact"><code>nksip_registrar:reg_contact()</code></a>], TTL::integer()}</code></td>
        <td><code>ok</code></td>
        <td>Store the list of contacts for this AOR. The record must be
            automatically deleted after TTL seconds.</td></tr>
   <tr><td><code>{del, AOR::<a href="nksip.html#type-aor"><code>nksip:aor()</code></a>}</code></td>
       <td><code>ok|not_found</code></td>
       <td>Delete all stored contacts for this AOR, returning <code>ok</code> or
           <code>not_found</code> if the AOR is not found.</td></tr>
   <tr><td><code>del_all</code></td>
       <td><code>ok</code></td>
       <td>Delete all stored information for this AppId.</td></tr>
 </table>
 
 
  The function must return <code>{reply, Reply, NewState}</code>.
  This default implementation uses the built-in memory database.</p>

<h3 class="function"><a name="reinvite-3">reinvite/3</a></h3>
<div class="spec">
<p><tt>reinvite(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(<a href="nksip.html#type-sipreply">nksip:sipreply()</a>)</tt><br></p>
</div><p><p>This function is called when a new in-dialog INVITE request is received.</p>
 
  <p>The guidelines in <a href="#invite-4"><code>invite/4</code></a> are valid, but you shouldn't send provisional  
responses, but a final response inmediatly.</p>
 
  If the dialog's target or the SDP session parameters are updated by the request or
  its response, <a href="#dialog_update-3"><code>dialog_update/3</code></a> and/or <a href="#session_update-3"><code>session_update/3</code></a> would be
  called.
 </p>

<h3 class="function"><a name="route-6">route/6</a></h3>
<div class="spec">
<p><tt>route(Scheme::<a href="nksip.html#type-scheme">nksip:scheme()</a>, User::binary(), Domain::binary(), ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(<a href="#type-route_reply">route_reply()</a>)</tt><br></p>
</div><p><p>This function is called by NkSIP for every new request, to check if it must be
  proxied, processed locally or replied immediately. For convenience, the scheme, user
  and domain parts of the <i>Request-Uri</i> are included.</p>
 
  <p>If we want to <b>act as a proxy</b> and route the request, and we are not responsible
  for <code>Domain</code> we must return <code>proxy</code> or <code>{proxy, ruri, ProxyOpts}</code>.
  We must not return an <code>UriSet</code> in this case.
  NkSIP will then make additional checks to the request (like inspecting the
  <code>Proxy-Require</code> header) and will route it statefully to the same <code>Request-URI</code>  
contained in the request.</p>
 
  If we are the resposible proxy for <code>Domain</code> we can provide a new list
  of URIs to route the request to. NkSIP will use <b><i>serial</i> and/or
  <i>parallel</i> forking</b> depending on the format of <code>UriSet</code>.
  If <code>UriSet</code> is a simple Erlang array of binaries representing uris, NkSIP will try
  each one serially. If any of the elements of the arrary is in turn a new array
  of binaries, it will fork them in parallel.
  For example, for  <pre>  [ &lt;&lt;"sip:aaa"&gt;&gt;, [&lt;&lt;"sip:bbb"&gt;&gt;, &lt;&lt;"sip:ccc"&gt;&gt;], &lt;&lt;"sip:ddd"&gt;&gt;]</pre><p>
  NkSIP will first forward the request to <code>aaa</code>. If it does not receive a successful
  (2xx) response, it will try <code>bbb</code> and <code>cccc</code> in parallel.
  If no 2xx is received again, <code>ddd</code> will be tried. See <a href="nksip_registrar.html"><code>nksip_registrar</code></a>
  to find out how to get the registered contacts for this <code>Request-Uri</code>.</p>
 
  Available options for <code>ProxyOpts</code> are:
  <ul>
   <li><code>stateless</code>: Use it if you want to proxy the request <i>statelessly</i>.
        Only one URL is allowed in <code>UriSet</code> in this case.</li>
   <li><code>record_route</code>: NkSIP will insert a <i>Record-Route</i> header before sending
       the request, so that following request inside the dialog will be routed
       to this proxy.</li>
   <li><code>follow_redirects</code>: If any 3xx response is received, the received contacts
       will be inserted in the list of uris to try.</li>
   <li><code>{route, <a href="nksip.html#type-user_uri"><code>nksip:user_uri()</code></a>}</code>:
       NkSIP will insert theses routes as <i>Route</i> headers
       in the request, before any other existing <code>Route</code> header.
       The request would then be sent to the first <i>Route</i>.</li>
   <li><code>{headers, [<a href="nksip.html#type-header"><code>nksip:header()</code></a>]}</code>:
       Inserts these headers before any existing header.</li>
   <li><code>remove_routes</code>: Removes any previous <i>Route</i> header in the request.
       A proxy should not usually do this. Use it with care.</li>
   <li><code>remove_headers</code>: Remove previous non-vital headers in the request.
       You can use modify the headers and include them with using <code>{headers, Headers}</code>.
       A proxy should not usually do this. Use it with care.</li>
  </ul>
 
  <p>If we want to <b>act as an endpoint or B2BUA</b> and answer to the request
  from this SipApp, we must return <code>process</code> or <code>{process, ProcessOpts}</code>.
  NkSIP will then make additional checks to the request (like inspecting
  <code>Require</code> header), start a new transaction and call the function corresponding
  to the method in the request (like <code>invite/3</code>, <code>options/3</code>, etc.)</p>
 
  Available options for <code>ProcessOpts</code> are:
  <ul>
   <li><code>stateless</code>: Use it if you want to process this request <i>statelessly</i>.
        No transaction will be started.</li>
  <li><code>{headers, [<a href="nksip.html#type-header"><code>nksip:header()</code></a>]}</code>:
      Insert these headers before any existing header, before calling the next
      callback function.</li>
  </ul>
 
  <p>We can also <b>send a reply immediately</b>, replying <code>{response, Response}</code>,
  <code>{response, Response, ResponseOpts}</code> or simply <code>Response</code>. See <a href="nksip_reply.html"><code>nksip_reply</code></a>
  to find the recognized response values. The typical reason to reply a response here
  is to send <b>redirect</b> or an error like <code>not_found</code>, <code>ambiguous</code>,
  <code>method_not_allowed</code> or any other. If the form <code>{response, Response}</code> or
  <code>{response, Response, ResponseOpts}</code> is used the response is sent statefully,
  and a new transaction will be started, unless <code>stateless</code> is present in <code>ResponseOpts</code>.
  If simply <code>Response</code> is used no transaction will be started.
  The only recognized option in <code>ResponseOpts</code> is <code>stateless</code>.</p>
 
  If route/3 is not defined the default reply would be <code>process</code>.
 </p>

<h3 class="function"><a name="session_update-3">session_update/3</a></h3>
<div class="spec">
<p><tt>session_update(DialogId::<a href="nksip_dialog.html#type-id">nksip_dialog:id()</a>, SessionStatus, State::term()) -&gt; <a href="#type-call_noreply">call_noreply()</a></tt>
<ul class="definitions"><li><tt>SessionStatus = {start, Local, Remote} | {update, Local, Remote} | stop</tt></li><li><tt>Local = <a href="nksip_sdp.html#type-sdp">nksip_sdp:sdp()</a></tt></li><li><tt>Remote = <a href="nksip_sdp.html#type-sdp">nksip_sdp:sdp()</a></tt></li></ul></p>
</div><p><p>Called when a dialog has updated its SDP session parameters.</p>
 
  <p>When NkSIP detects that, inside an existing dialog, both parties have agreed on
  a specific SDP defined session, it will call this function.
  You can use the functions in <a href="nksip_sdp.html"><code>nksip_sdp</code></a> to process the SDP data.</p>
 
  This function will be also called after each new successful SDP negotiation.
 </p>

<h3 class="function"><a name="subscribe-3">subscribe/3</a></h3>
<div class="spec">
<p><tt>subscribe(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(<a href="nksip.html#type-sipreply">nksip:sipreply()</a>)</tt><br></p>
</div><p><p>This function is called by NkSIP to process a new incoming SUBSCRIBE  
request that has an allowed Event type.</p>
 
  <p>If you reply a 2xx response like <code>ok</code>  or <code>accepted</code>, a dialog and a subscription
  will start, and you must inmeditaly send a NOTIFY using
  <a href="nksip_uac.html#notify-3"><code>nksip_uac:notify/3</code></a>.</p>
 
  You can use the option <code>{expires, integer()}</code> to override the expires present
  in the request, but the new value must be lower, or even 0 to cancel the
  subscription.
 </p>

<h3 class="function"><a name="terminate-2">terminate/2</a></h3>
<div class="spec">
<p><tt>terminate(Reason::term(), State::term()) -&gt; ok</tt><br></p>
</div><p>Called when the SipApp is stopped.</p>

<h3 class="function"><a name="update-3">update/3</a></h3>
<div class="spec">
<p><tt>update(ReqId::<a href="nksip_request.html#type-id">nksip_request:id()</a>, From::<a href="#type-from">from()</a>, State::term()) -&gt; <a href="#type-call_reply">call_reply</a>(<a href="nksip.html#type-sipreply">nksip:sipreply()</a>)</tt><br></p>
</div><p><p>Called when a valid UPDATE request is received.</p>
 
  <p>When a UPDATE request is received, NkSIP will automatically response 481
  <i>Call/Transaction does not exist</i> if it doesn't belong to a current dialog.  
If it does, this function is called.</p>
 
  The request will probably have a SDP body.
  If a <code>ok</code> is replied, a SDP answer is inclued, the session may change
  (and the corresponding callback function will be called).
  If other non 2xx response is replied (like decline) the media is not changed.
 </p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Dec 12 2013, 19:52:59.</i></p>
</body>
</html>
