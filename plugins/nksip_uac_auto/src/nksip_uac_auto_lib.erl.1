%% -------------------------------------------------------------------
%%
%% Copyright (c) 2013 Carlos Gonzalez Florido.  All Rights Reserved.
%%
%% This file is provided to you under the Apache License,
%% Version 2.0 (the "License"); you may not use this file
%% except in compliance with the License.  You may obtain
%% a copy of the License at
%%
%%   http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing,
%% software distributed under the License is distributed on an
%% "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
%% KIND, either express or implied.  See the License for the
%% specific language governing permissions and limitations
%% under the License.
%%
%% -------------------------------------------------------------------

%% @private nksip_uac_auto plugin callbacksuests and related functions.
-module(nksip_uac_auto_lib).
-author('Carlos Gonzalez <carlosj.gf@gmail.com>').

-export([parse_config/3]).
-export([launch_register/2, launch_unregister/2, update_register/4]).
-export([launch_ping/2, update_ping/4]).

-include("../../../include/nksip.hrl").
-include("nksip_uac_auto.hrl").


% @private
-spec parse_config(PluginConfig, Unknown, Config) ->
    {ok, Unknown, Config} | {error, term()}
    when PluginConfig::nksip:optslist(), Unknown::nksip:optslist(), 
         Config::nksip:optslist().

parse_config([], Unknown, Config) ->
    {ok, Unknown, Config};

parse_config([Term|Rest], Unknown, Config) ->
    Op = case Term of
        {nksip_uac_auto_register, Register} ->
            case nksip_parse:uris(Register) of
                error -> error;
                Uris -> {update, Uris}
            end;
        {nksip_uac_auto_register_expires, Expires} ->
            case is_integer(Expires) andalso Expires>0 of
                true -> update;
                false -> error
            end;
        {nksip_uac_auto_timer, Timer} ->
            case is_integer(Timer) andalso Timer>0 of
                true -> update;
                false -> error
            end;
        _ ->
            unknown
    end,
    case Op of
        update ->
            Key = element(1, Term),
            Val = element(2, Term),
            Config1 = [{Key, Val}|lists:keydelete(Key, 1, Config)],
            parse_config(Rest, Unknown, Config1);
        {update, Val} ->
            Key = element(1, Term),
            Config1 = [{Key, Val}|lists:keydelete(Key, 1, Config)],
            parse_config(Rest, Unknown, Config1);
        error ->
            {error, {invalid_config, element(1, Term)}};
        unknown ->
            parse_config(Rest, [Term|Unknown], Config)
    end.




%%%%%% Register

%% @private
-spec launch_register(nksip:app_id(), #sipreg{}) -> 
    #sipreg{}.

launch_register(AppId, Reg)->
    #sipreg{id=RegId, ruri=RUri, opts=Opts, cseq=CSeq} = Reg,    
    Opts1 = [{cseq_num, CSeq}, {meta, [cseq_num, retry_after]}|Opts],
    Self = self(),
    Fun = fun() ->
        case nksip_uac:register(AppId, RUri, Opts1) of
            {ok, Code, Meta} -> ok;
            _ -> Code=500, Meta=[{cseq_num, CSeq}]
        end,
        gen_server:cast(Self, {'$nksip_uac_auto_register_answer', RegId, Code, Meta})
    end,
    spawn_link(Fun),
    Reg#sipreg{next=undefined}.
    

%% @private
-spec launch_unregister(nksip:app_id(), #sipreg{}) -> 
    ok.

launch_unregister(AppId, Reg)->
    #sipreg{ruri=RUri, opts=Opts, cseq=CSeq} = Reg,
    Opts1 = [{cseq_num, CSeq}|lists:keystore(expires, 1, Opts, {expires, 0})],
    nksip_uac:register(AppId, RUri, Opts1),
    ok.

   
%% @private
-spec update_register(#sipreg{}, nksip:sip_code(), nksip:optslist(), #state{}) ->
    #sipreg{}.

update_register(Reg, Code, _Meta, _State) when Code<200 ->
    Reg;

update_register(Reg, Code, Meta, _State) ->
    #sipreg{interval=Interval, from=From} = Reg,
    case From of
        undefined -> ok;
        _ -> gen_server:reply(From, {ok, Code<300})
    end,
    Time = case Code==503 andalso nksip:get_value(retry_after, Meta) of
        false -> Interval;
        undefined -> Interval;
        Retry -> Retry
    end,
    Reg#sipreg{
        ok = Code < 300,
        cseq = nksip_lib:get_value(cseq_num, Meta) + 1,
        from = undefined,
        next = nksip_lib:timestamp() + Time
    }.


%%%%%% Ping

%% @private
-spec launch_ping(nksip:app_id(), #sipreg{}) -> 
    #sipreg{}.

launch_ping(AppId, Ping)->
    #sipreg{id=PingId, ruri=RUri, opts=Opts, cseq=CSeq} = Ping,
    Opts1 = [{cseq_num, CSeq}, {meta, [cseq_num, retry_after]} | Opts],
    Self = self(),
    Fun = fun() ->
        case nksip_uac:options(AppId, RUri, Opts1) of
            {ok, Code, Meta} -> ok;
            _ -> Code=500, Meta=[{cseq_num, CSeq}]
        end,
        gen_server:cast(Self, {'$nksip_uac_auto_ping_answer', PingId, Code, Meta})
    end,
    spawn_link(Fun),
    Ping#sipreg{next=undefined}.


   
%% @private
-spec update_ping(#sipreg{}, nksip:sip_code(), nksip:optslist(), #state{}) ->
    #sipreg{}.

update_ping(Ping, Code, _Meta, _State) when Code<200 ->
    Ping;

update_ping(Ping, Code, Meta, _State) ->
    #sipreg{from=From, interval=Interval} = Ping,
    case From of
        undefined -> ok;
        _ -> gen_server:reply(From, {ok, Code<300})
    end,
    Time = case Code==503 andalso nksip:get_value(retry_after, Meta) of
        false -> Interval;
        undefined -> Interval;
        Retry -> Retry
    end,
    Ping#sipreg{
        ok = Code < 300,
        cseq = nksip_lib:get_value(cseq_num, Meta) + 1,
        from = undefined,
        next = nksip_lib:timestamp() + Time
    }.





